# Модули

## Содержание 

* README.md - конспект главы 16.
* */ - папки, которые представляют собой модули, которые используются в главе 16.

## Конспект

Модули представляют способ описания отношений и зависимостей кода, из которого состоит приложение. Модули также позволяют контролировать
то, какие части модуля доступны другим модулям, а какие - нет. За счет использования модулей можно создавать более надёжные и масштабируемые
программы.

В наиболее основополагающем смысле **модуль** представляет собой группу пакетов и ресурсов, на которые можно коллективно ссылаться 
по имени модуля. В **объявлениях модуля** указывается имя модуля и определяется отношение модуля и его пакетов с другими модулями.
Объявления модулей записываются в виде операторов в файле исходного кода Java и поддерживаются несколькими ключевыми словами, связанными с модулями:
* **exports** - экспортирует пакеты (без to всем);
* **module** - объявление модуля;
* **open** - делает модуль открытым;
* **opens** - делает пакеты открытыми (+ to);
* **provides** - предоставляет провайдера для чего-то (with) с помощью вот этого;
* **requires** - требует другой модуль;
* **to** - используется для указания конкретики;
* **transitive** - делает доступным модули, транзитивно от них зависящие;
* **uses** - использует провайдера;
* **with** -  используется с provides.

Ключевые слова только в контексте объявления модуля. Объявление модуля содержится в файле по имени **module-info.java**, 
то есть модуль определяется в файле исходного кода Java. Файл компилируется в файл класса и известен как его **дескриптор модуля**.
Объявление модуля начинается с ключевого слова module:

```java
module имя-модуля {
    // определение модуля
}
```

Отношение зависимостей задаётся с помощью requires.

```java
module A {
    requires B;
    requires C;
}
// Модуль A зависит (использует, требует) модули B и C.
```

Контроль за пакетами доступными другому модулю осуществляется с помощью exports.

```java
module A {
    exports com.example.first;
    exports com.example.second to B;
}
// Модуль А даёт доступ к своему пакету com.example.first всем (надо только указать зависимости)
// а пакет com.example.second только B (тоже надо указать зависимость)
```

По причине своей важности модуль java.base автоматически доступен всем модулям. Все остальные модули автоматически требуют java.base.

Для поддержки унаследованного кода предназначены два ключевых средства. Одно из них неименованный модуль. Когда вы используете код, не 
являющийся частью именованного модуля, он автоматически становится частью неименованного модуля, который обладает двумя важными характеристиками.
Все пакеты в неименованном модуле автоматически экспортируются. Неименованный модуль имеет доступ автоматически ко всем остальным модулям.
Вторым ключевым средством, поддерживающим унаследованный код, следует считать автоматическое использование пути к классу, а не пути
к модулю.

Если модуль A зависит от модуля B, а модуль B зависит от C, то можно использовать ключевое слово transitive, чтобы автоматически
делать зависимость, то есть чтобы для A было видно помимо B, ещё и С.

```java
module C {
    exports com.example.packageC;
}
//
module B {
    exports com.example.packageB;
    
    requires transitive C;
}
//
module A {
    requires B;
}
// D А видны пакеты и D и С.
```

Использование служб и поставщиков служб осуществляется с помощью ключевых слов provides, with, uses. Например, если модуль A, это наша текущая программа,
модуль B - это интерфейс к службе, модуль С - это поставщик службы (конкретная реализация), то это выглядит примерно так:

```java
module A {
    requires B;
    
    uses com.example.provideInterface.NameInterface;
}

module B {
    exports com.example.baseInterface;
    exports com.example.provideInterface;
}

module C {
    requires B;
    
    provides com.example.provideInterface.NameInterface 
        with com.example.provideImplementation.NameImplemantation;
}
```

Теперь, если мы захотим поменять поставщика, то просто переключимся с модуля C; например на D модуль:

```java
module D {
    requires B;
    
    provides com.example.provideInterface.NameInterface 
        with com.example.provideImplementation.OtherImplemantation;
}
```

