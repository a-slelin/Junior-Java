# Перечисления, автоупаковка и аннотации

## Содержание 

* README.md - конспект главы 12.
* src/*.java - примеры программ из главы 12.

## Конспект

## Перечисления

В своей простейшей форме **перечисления** представляют собой список именованных констант.

```java
enum Color {
    RED, BLACK
} //final + static + public
```

Такие константы называют **самотипизированными**. Enum можно использовать в switch, причём в case не обязательно уточнять
тип перечисления. 

Все перечисления автоматически содержат в себе два предопределённых метода:

```java
public static enum-type[] values();
public static enum-type valueOf(String str);
```

Первый метод возвращает массив констант перечисления. Второй метод возвращает константу перечисления, значение которой 
соответствует строке, переданной в аргументе str.

Перечисление относится к типу класса. Можно предоставлять конструкторы, переменные и методы и даже реализовать интерфейс.
Перечисление не может быть унаследовано и его нельзя расширять. 

Несмотря на невозможность при объявлении перечисления наследовать его от супер-класса, все перечисления автоматически унаследованы от 
java.lang.**Enum**. В этом классе определено несколько методов доступных для использования всеми перечислениями.

```java
final int ordinal(); // Порядковый номер константы в списке.
final int compareTo(enum-type e);
equals(); // Переопределён из Object
```

## Оболочки типов

Оболочки типов представляют собой классы, инкапсулирующие примитивный тип внутри объекта.

```java
double -> Double();
float -> Float();
long -> Long();
int -> Integer();
short -> Short();
byte -> Byte();
char -> Character();
boolean -> Boolean();
```

### Character

```java
static Character valueOf(char c); // Возвращает объект Character, содержащий внутри себя char c.
char charValue(); // Получаем значение char
```
Конструкторы не используем (устарели).

### Boolean

Конструкторы не используем (устарели).

```java
static Boolean valueOf(String boolString);
static Boolean valueOf(boolean boolValue);
boolean booleanValue(); // Получение значения boolean
```
В первом методе если аргумент "true" в любом регистре, тогда true, а иначе false. Во втором методе соответствует true и false.

### Числовые типы

Все оболочки числовых типов унаследованы от абстрактного класса **Number**. В классе объявлены методы, которые возвращают 
значение объекта в каждом из различных вариантов:

```java
byte byteValue();
double doubleValue();
float floatValue();
int intValue();
long longValue();
short shortValue();
```

Во всех оболочках числовых типов определены конструкторы, которые позволяют создавать объект из заданного значения или строкового
представления этого значения. Например, 

```java
Integer(int n);
Integer(String str);
```

Если в аргументе str не содержится допустимое числовое значение, тогда сгенерируется исключение NumberFormatException. 
Конструкторы считаются устаревшими. Используем valueOf:

```java
static Integer valueOf(int val);
staic Integer valueOf(String valStr) throws NumberFormatException;
```

Целочисленные оболочки также предоставляют форму, позволяющую указать систему счисления.

Процесс инкапсуляции значения внутри объекта называется **упаковкой**. Процесс извлечения значения из оболочки типа называется
**распаковкой**. Современные версии Java включают два важных средства: автоупаковка и автораспаковка. **Автоупаковка** - это процесс,
с помощью которого примитивный тип автоматически инкапсулируется в эквивалентную ему оболочку типа всякий раз, когда требуется объект такого
типа. **Автораспаковка** - это процесс, при котором значение упакованного объекта автоматически извлекается из оболочки типа, 
когда значение необходимо.

## Аннотации

Язык Java предлагает средство, позволяющее встраивать дополнительную информацию в файл исходного кода. Такая информация, 
называемая **аннотацией**, не меняет действия программы. Однако данная информация может использоваться разнообразными инструментами
во время развёртывания. Для обозначения этого средства также применяется термин **метаданные**.

Аннотация создаётся с помощью механизма, основанного на интерфейсе.

```java
@interface MyAnno{
    String str();
    int val();
}
```
@ - сообщение компилятору, что объявляется тип аннотации.

Все аннотации состоят исключительно из объявления методов. Мы не предоставляем тела для этих методов.

Аннотация не может содержать конструкцию extends. Однако все типы аннотаций автоматически расширяют интерфейс **Annotation**,
который является супер-интерфейсом для всех аннотаций. Находится в java.lang.annotation и переопределяет методы hashCode(), 
equals(), toString(). Задаёт **annotationType()**, который возвращает объект Class, представляющий вызывающую аннотацию.

Любой тип объявления может иметь ассоциированную с ним аннотацию (классы, методы, поля, параметры, константы перечислений и т.д.).
Аннотировать можно и саму аннотацию.

```java
@MyAnno(str="Example", val=100)
public static void myMethod(){}
```

В данном контексте члены аннотации выглядят как поля.

## Политика хранения

Политика хранения устанавливает момент, когда аннотация отбрасывается. Определены три такие политики, которые инкапсулированы
внутри перечисления java.lang.annotation.**RetentionPolicy** - **SOURCE**, **CLASS**, **RUNTIME**. 
* Аннотация с политикой хранения SOURCE удерживается только в файле исходного кода и на этапе компиляции отбрасывается.
* Аннотация с политикой хранения CLASS на этапе компиляции сохраняется в файл .class. Однако она не будет доступной через машину JVM
во время выполнения.
* Аннотация с политикой хранения RUNTIME на этапе компиляции сохраняется в файл .class и доступна через машину JVM во время
выполнения. RUNTIME обеспечивает наивысшее постоянство аннотаций.

Политика хранения для аннотаций указывается с применением одной из встроенных аннотаций:

```java
import java.lang.annotation.Retention;

@Retention(retention-policy)
```

Стандартная политика хранения CLASS.

## Рефлексия

Аннотации предназначены главным образом для использования другими инструментами разработки или развёртывания. Тем не менее, 
если для аннотаций определена политика хранения RUNTIME, тогда их можно запрашивать во время выполнения с помощью любой программы
на Java через рефлексию. **Рефлексия** представляет собой средство, позволяющее получать информацию о классе во время выполнения.
API рефлексии содержится в пакете java.lang.reflect.

Первым шагом к использованию рефлексии является получение объекта Class, представляющего класс, аннотации которого вы хотите получить.
Class находится в java.lang. Существуют различные способы получения объекта Class Один из самых простых вызов метода getClass(), определённый
в Object:

```java
final Class<?> getClass();
```

После того как объект Class получен, с помощью его методов можно просматривать информацию о различных элементах, объявленных в классе,
в том числе об аннотациях.

```java
getMethod();
getField();
getConstructor();
//...
```

Например:

```java
Method getMethod(String methName, Class<?> ... paramTypes) throws NoSuchMethodException;
```

Вызывая метод getAnnotation(), из объекта Class, Method, Field, Constructor можно получить специфическую аннотацию, ассоциированную с 
этим объектом.

```java
<A extends Annotation> getAnnotation(Class<A> annoType);
```

annoType - объект класса, представляющей интересующую аннотацию. Метод возвращает ссылке на аннотацию. С применением такой
ссылки можно получить значения, связанные с членами аннотации. Метод возвращает null если аннотация не найдена, что происходит, когда 
аннотация не имеет политики хранения RUNTIME.

**Литерал класса** (MyAnno.class) - результат вычисления данного выражения является объект Class типа MyAnno.

Чтобы получить все аннотации с политикой хранения RUNTIME, ассоциированные с элементом, можно вызвать на данном элементе
метод getAnnotations():

```java
Annotation[] getAnnotations();
```

## AnnotatedElement

Методы getAnnotation() и getAnnotations() определены в интерфейсе **AnnotatedElement** из пакета java.lang.reflect. Он поддерживает
рефлексию для аннотаций и реализован среди прочего классами Method, Field, Constructor, Class, Package. Ещё есть:

```java
Annotation[] getDeclaredAnnotations(); // Возвращает все неунаследованные аннотации,
//присутствующие в вызывающем объекте 
default boolean isAnnotationPresent(Class<? extends Annotation> annoType); // возвращает true,
// если аннотация ассоциирована с вызывающим объектом, в противном случае false
```

Также были добавлены

```java
getDeclaredAnnotaion();
getAnnotaionsBytType(); //для повторяющихся аннотаций
getDeclaredAnnotationsByType(); //для повторяющихся аннотаций
```

## Стандартные значения 

Для членов аннотации можно задавать стандартные значения, которые будут использоваться, если при применении аннотации не указано
значение:

```java
type member() default value;

String str() default "test";
```

## Маркерные аннотации 

Маркерная аннотация является специальным видом аннотации, не содержащим членов. Её единственная цель - пометить элемент.
Лучший способ определить наличие маркерной аннотации предусматривает применение метода isAnnotationPresent(), который
определён в интерфейсе AnnotatedElement.

## Одноэлементные аннотации

Одноэлементная аннотация содержит только один член. Она работает как нормальная аннотация за исключением того, что позволяет
использовать сокращённую форму для указания значения члена. Для использования сокращения именем члена должно быть **value**.

## Встроенные аннотации

В Java определено множество встроенных аннотаций. Большинство из них специализированы, но одиннадцать являются аннотациями общего
назначения.

6 в java.lang.annotation:
1) @Retention
2) @Documented
3) @Target
4) @Inherited
5) @Native
6) @Repeatable

5 в java.lang:
1) @Override
2) @Deprecated
3) @FunctionalInterface
4) @SafeVarArgs
5) @SuppressWarnings

## @Retention

Аннотация рассчитана только на применение к другой аннотации. Она определяет политику хранения.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Retention {
    RetentionPolicy value();
}
```
Политика:

```java
public enum RetentionPolicy {
    SOURCE,
    CLASS,
    RUNTIME
}
```

## @Documented

Аннотация @Documented представляет собой маркерный интерфейс, который сообщает инструменту о том, что аннотация
должна быть документирована. Она предназначена для использования только в качестве аннотации к объявлению аннотации.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Documented {
}
```

## @Target

С помощью аннотации задаются типы элементов, к которым может применяться аннотация. Она спроектирована для использования только в
качестве аннотации к другой аннотации. Принимает один аргумент, представляющий собой массив констант перечисления ElementType.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Target {
    ElementType[] value();
}
```

Типы:

```java
public enum ElementType {
    TYPE, //класс, перечисление, интерфейс
    FIELD,
    METHOD,
    PARAMETER,
    CONSTRUCTOR,
    LOCAL_VARIABLE,
    ANNOTATION_TYPE,
    PACKAGE,
    TYPE_PARAMETER, //параметр типа
    TYPE_USE, //использование типа
    MODULE,
    RECORD_COMPONENT;
}
```

## @Inherited

Маркерная аннотация, которую можно использовать только в объявлении другой аннотации. Кроме того, влияет только на аннотации, которые
будут применяться в объявлениях классов. Указание @Inherited приводит к тому, что аннотация для супер-класса наследуется подклассом.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Inherited {
}
```

## @Native

Маркерная аннотация, которая применяется к полям. Указывает, что на поле, определяющее постоянное значение, можно 
ссылаться из машинного кода. Аннотация может использоваться в качестве подсказки инструментами, которые генерируют 
собственные файлы заголовков, чтобы определить, требуется ли файл заголовка, и если да, то какие объявления он должен 
содержать.

```java
@Documented
@Target(ElementType.FIELD)
@Retention(RetentionPolicy.SOURCE)
public @interface Native {
}
```

## @Repeatable

Используется для указания, что определенная аннотация может быть применена к элементу кода несколько раз.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.ANNOTATION_TYPE)
public @interface Repeatable {
    Class<? extends Annotation> value();
}
```

## @Override

Маркерная аннотация, которую можно использовать только для методов. Метод с этой аннотацией должен переопределять метод из супер-класса, иначе
возникнет ошибка на этапе компиляции. Она применяется для гарантирования того, что метод супер-класса действительно переопределён, а
не перегружен.

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```

## @Deprecated

Аннотация указывает, что объявление устарело и не рекомендуется к употреблению. Позволяет указать версию Java, в которой
было заявлено об устаревании, и планируется ли удаление устаревшего элемента.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, MODULE, PARAMETER, TYPE})
public @interface Deprecated {
    String since() default "";
    boolean forRemoval() default false;
}
```

## @FunctionalInterface

Представляет собой маркерную аннотацию, предназначенную для использования в интерфейсах. **Функциональный интерфейс** -
это интерфейс, который содержит один и только один абстрактный метод. Функциональные интерфейсы задействованы в лямбда-выражениях.
Носит информационный характер.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface FunctionalInterface {}
```

## @SafeVarargs

Маркерная аннотация, которую можно применять к методам и конструкторам. Она указывает на отсутствие небезопасных действий,
связанных с аргументом переменной длины. Используется для подавления непроверяемых предупреждений в безопасном остальном коде.
Методы обязаны быть static, final или private.

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.CONSTRUCTOR, ElementType.METHOD})
public @interface SafeVarargs {}
```

## @SuppressWarnings

Указывает, что одно или несколько предупреждений, которые могут быть выданы компилятором, должны быть подавлены. Предупреждения,
подлежащие подавлению задаются по имени в строковой форме.

```java
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
```

## Аннотация типов

Первоначально аннотации были разрешены только в объявлениях. Современные версии Java позволяют указывать аннотации в большинстве случаев
использования типов. Такое расширенное свойство аннотаций называется **аннотациями типов**. Можно аннотировать возвращаемый тип метода,
тип this внутри метода, приведение, уровни массива, унаследованный класс и конструкцию throws. Аннотировать можно обобщённые типы. Аннотация
типа применяется к типу, которому она предшествует.

## Повторяющиеся аннотации 

Аннотацию разрешено многократно применять к одному и тому же элементу. Такие аннотации называются **повторяющимися**. Чтобы аннотацию можно было
повторять, её нужно снабдить аннотацией @Repeatable и указать в её поле value тип **контейнера** для повторяющейся аннотации.
Контейнер задаётся в виде аннотации, для которой поле value представляет собой массив типа повторяющейся аннотации. Для создания повторяющейся 
аннотации необходимо создать контейнерную аннотацию, после чего указать этот тип аннотации в качестве аргумента аннотации @Repeatable.

Чтобы получить доступ к повторяющимся аннотациям с помощью метода вроде getAnnotation(), будет использоваться контейнерная аннотация,
а не сама повторяющаяся аннотация.

Но методы, вроде getAnnotationByType() работают напрямую с повторяющейся аннотацией.

## Ограничения

* Ни одна аннотация не может быть унаследована от другой.
* Все методы в аннотации не имеют параметров.
* Методы возвращают только:
  * примитивный тип
  * объект типа String или Class
  * объект типа Enum
  * объект типа другой аннотации
  * массив одного из доступных типов
* Аннотации не могут быть обобщёнными.
* В методах аннотаций нельзя указывать конструкцию throws.

